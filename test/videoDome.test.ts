/**
 * @fileoverview Tests for the VideoDome creation
 * @author your instructors
 * @lastUpdated 2025-02-24
 *
 * @description 
 * This test file uses a headless browser to mainly test the VideoDome component.
 * This will only be useful for your local dev environment, as it requires a running server.
 * On the GitHub Actions CI, the VideoDome tests will be skipped because it is challenging to
 * configure a headless browser in a CI environment auto-generated by GitHub classrooms.
 */

import { VideoDome, Engine, VideoTexture, ArcRotateCamera } from "@babylonjs/core";
import puppeteer, { Browser, Page } from "puppeteer";
import { expect, test, describe, beforeAll, afterAll } from "vitest";

// real VideoDome test using a headless browser
describe("Real VideoDome test that:", () => {
    let browser: Browser;
    let page: Page;

    beforeAll(async () => {
        // Launch the browser
        browser = await puppeteer.launch({ headless: true }); // Set headless to true for CI environments
        page = await browser.newPage();

        // Navigate to the page
        // - this means the test command should specify the correct port 
        //   (although this is actually the default port)
        await page.goto("http://localhost:5173");

        // Wait for the canvas to be available in the DOM
        await page.waitForSelector("#renderCanvas");

        // DEBUG: Capture browser console logs and print to Node.js terminal
        // - uncomment to show browser console logs in the terminal during tests
        //page.on("console", (message) => {
            //console.log(
                //`Browser console (${message.type()}): ${message.text()}`
            //);
        //});
    });

    afterAll(async () => {
        // Close the browser
        await browser.close();
    });

    // test whether a video dome is created and try to pause and play the video
    test("should find and interact with (real) VideoDome object in a headless browser", async () => {

        // Check for VideoDome in the Babylon.js scene using page.evaluate (non-intrusive)
        const videoDomeFound = await page.evaluate(async () => {
            // Get engine instance from window object
            // - this means main.ts should set the engine instance to the window object
            const engine = (window as any).engine as Engine;
    
            //const engine = (window as any).engine as Engine;
            if (!engine) {
                console.warn(
                    "Babylon.js Engine instance not found. Is the engine created?"
                ); 
            } else {
                console.log(
                    "Babylon.js Engine instance found. Checking for VideoDome..."
                );
            }

            // Get the active scene from the engine
            const scene = engine?.scenes[0];
            if (!scene) {
                console.error(
                    "Babylon.js scene not found. Is a scene created?"
                );
                return false;
            }

            // Search for a TransformNode named "video dome" (VideoDome is a TransformNode)
            const videoDomeNode = scene.transformNodes.find((node: {name: string;}) => node.name === "video dome");
            if (!videoDomeNode) {
                console.error('VideoDome (as TransformNode) named "video dome" NOT found in scene.');
                return false;
            }

            // try to play the video
            const videoDome = videoDomeNode as VideoDome;
            const videoTexture = videoDome.material.diffuseTexture as VideoTexture;
            if (!videoTexture) {
                console.error('VideoTexture NOT found in VideoDome.');
                return false;
            }
            
            // Pause and play the video, and catch and throw any errors
            try {
                //await new Promise((resolve) => setTimeout(resolve, 1000));
                videoTexture.video.pause();
                //await new Promise((resolve) => setTimeout(resolve, 1000));
                videoTexture.video.play();
            } catch (error) {
                console.error('Error pausing and playing video:', error);
                return false;
            }

            //console.log('VideoDome component DETECTED (TextureDome with VideoTexture)!');
            return true; // All checks passed, VideoDome is likely correctly implemented
        });

        expect(videoDomeFound).toBe(true); // Assert that VideoDome was found
    });

    // test whether a arc rotate camera is created and try to rotate it
    test("should find and interact with an ArcRotateCamera object in a headless browser", async () => {

        // Check for ArcRotateCamera in the Babylon.js scene using page.evaluate (non-intrusive)
        const arcRotateCameraFound = await page.evaluate(async () => {
            // Get engine instance from window object
            // - this means main.ts should set the engine instance to the window object
            const engine = (window as any).engine as Engine;
    
            //const engine = (window as any).engine as Engine;
            if (!engine) {
                console.error(
                    "Babylon.js Engine instance not found. Is the engine created?"
                ); 
            } else {
                console.log(
                    "Babylon.js Engine instance found. Checking for ArcRotateCamera..."
                );
            }

            // Get the active scene from the engine
            const scene = engine?.scenes[0];
            if (!scene) {
                console.error(
                    "Babylon.js scene not found. Is a scene created?"
                );
                return false;
            }

            // Get the first camera in the scene
            const camera = scene?.activeCamera as ArcRotateCamera;

            // Check if the first camera is an ArcRotateCamera
            if (!camera) {
                console.log('No ArcRotateCamera found in scene.');
                return false;
            }
            
            // Try to rotate the camera
            try {
                //await new Promise((resolve) => setTimeout(resolve, 1000));
                camera.alpha += 0.3;
                //await new Promise((resolve) => setTimeout(resolve, 1000));
            } catch (error) {
                console.error('Error rotating camera:', error);
                return false;
            }

            return true; // All checks passed, ArcRotateCamera is likely correctly implemented
        });

        expect(arcRotateCameraFound).toBe(true); // Assert that ArcRotateCamera was found
    });
});
